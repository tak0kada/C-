<a name="top"></a>
* [11月7日](#117)
* [11月14日](#1114)
* [11月21日](#1121)
* [11月28日](#1128)

# <a name="117"></a>2015/11/7 [↑](#top)
* 参加者: 岩崎、中尾、村田
* <http://www.asahi-net.or.jp/~yf8k-kbys/newcpp6.html>から

## 第6章
第6章はクラスの文法について
```cpp
// 全部入りクラス
class Person {
public:
  Person(const std::string &s, const int a) {
    name = s;
    age = a;
  }
private:
  string name;
  int age;
};

// 宣言と定義は別にできる
class Person{
...
  Person(const std::string &, const int);
...
};
Person::Person(...){...}

// 初期化リストを使うと2回初期化する必要がなくなる(ただし初期化の順序はランダム)
Person::Person(const std::string &s, const int a)
  : name(s)
  , age(a)
{}
```
``::``はスコープ解決演算子。クラスに含まれる変数、関数をメンバ変数(データメンバ)、メンバ関数という。

constをつけると指定した変数が変化しないようにできる。TODO
```cpp
// Personがconst???←正しそう。mutableを勉強するとよい。
void Person::speak() const {}
// 返り値がconst
const int Person::speak() {}
```

## 第7章
第7章は条件分岐について
* if、else
```cpp
if (a < b)
  cout << "a < b";
else if (a > b)
  cout << "a > b";
else
  cout << "a == b"
```

* switch: フォロースルー(条件が正しければ下のcaseまで実行されてしまう)するのでbreakを入れること
```cpp
switch (signal) {
  case 'r':
    cout << "stop";
    break;
  case 'y':
    break;
  case 'b':
    break;
  default:
    // 上の条件に全て当てはまらなかった場合
}
```

## 第8章
第8章は関数のオーバーロードについて

C++では引数の型、個数が違う同名の関数を定義して使い分けることができる。
```cpp
int foo(double a)
int foo(double a, double b)
// 以下を定義するとどの型を使うかコンパイラが分からないのでエラー(foo(1.0)の1.0はdouble?それともfloat?)
// int foo(float a)
```

これはコンストラクタでも同じことが出来る。何も定義しないとデフォルトコンストラクタが定義されるが、それ以外のコンストラクタも定義できる。
```cpp
class BookShelf {
public:
    BookShelf(){};
    BookShelf(std::string book) {
      mBooks.push_back(book);
    }
private:
    std::vector<std::string> mBooks;
};

int main(){
    BookShelf MyBooks;
    BookShelf YourBooks("C++Book");
}
```
## 第10章
* <http://en.cppreference.com/w/cpp/numeric/random>に説明がある。
* とりあえずcstdlibをインクルードしてCスタイルのrandを使うのはランダム性に問題があるからやめよう。

## 第11章
第11章はループについて。無限ループに注意。

* for
```cpp
for (int i = 0; i < 10; ++i) {
  for (int j = 0; j < 10; ++j) {
  }
}
```
* while
```cpp
while (true) {
  break;
}
```
* do-while
```cpp
do {
  cout << i;
} while (i < 3);
```
## 練習
* 2つの数の比較をしてみる
  * 解答: <https://gist.github.com/tak0kada/e984b81bd369e455dde6>
* 文字列を反転してみる
  * 解答その1: <https://gist.github.com/tak0kada/6ee2ad832cc6437ae3f5>
  * 解答その2: <http://melpon.org/wandbox/permlink/1DNixYTZg86yRr2x>
  * 解答その3: <https://gist.github.com/tak0kada/143ba72cc2e1d927242a>

## 議論
* lvalue、rvalue、xvalue、prvalueって何???int&&とは????
  * ↑理解できていないので見つかったページを記録しておく
  * <http://qiita.com/rinse_/items/0139dd8598f2d58e668c>
  * <http://staryoshi.hatenablog.com/entry/2014/02/25/094816>
  * <http://d.hatena.ne.jp/iorate/20111207/1323280542>
  * <http://cpplover.blogspot.jp/2009/11/rvalue-reference_23.html>
  * <http://suikaba.hatenablog.com/entry/2013/05/13/222847>

# <a name="1114"></a>2015/11/12 [↑](#top)
* 参加者: 岩崎、岡田、
<http://www.asahi-net.or.jp/~yf8k-kbys/newcpp12.html>から。12~14章は内容が薄いため飛ばした。
15章
継承
class Base;
基底クラス

宣言
class Derived : public Base {
...
};
派生クラス
定義
Derived::Derived(): Base(), ..{}
Derived::Derived()
  : Base()
  , ..
{}

16章
void型はreturn;とすれば良い
基底クラスのメンバに対するアクセス
public（だれでもアクセス化）-> protected（派生クラスからアクセス化） -> private （だれもアクセス不可能)
派生クラスを作った時はメンバはそのまま引き継がれる。public、protected、private継承のそれぞれでメンバの外部への公開の仕方が変わる。
[表]

17章もパス
18章
class Cat{
TODO pulic:
  ~Cat(){}
};
デストラクタはインスタンスを破棄するときに呼ばれる関数
19章はCスタイルなので見なかったことにする
20章: ポインタ
&でアドレスを取れる
左に書く*でポインタを宣言
int *px = &x;

const int *px = &x;
//error
*px = 1;

int * const px = &x;
//error
px++
//ok
*px = 1;

ポインタからメンバ関数を呼ぶ
px->func();

class Person;
class Company{
private:
  //例1:色々な会社に属する人がいる場合に重い(or厄介)
  std::vector<Person> People;
  //例2
  std::vector<*Person> People;
};

Person *p = new Person();
delete p;
http://www.asahi-net.or.jp/~yf8k-kbys/newcpp16.html
http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/inherit_access.php


1問目
ポインタを2つ受け取ってそれらが指し示す値で並べ替える関数
void sort(int *a, int *b);
//期待される動作
int n1 = 10, n2 = 1;
sort(&n1, &n2);
//n1 == 1, n2 == 10


```解答
#include <iostream>
void swap(int *a, int *b) {
  int t = *a;
  *a = *b;
  *b = t;
}

void sort2(int *a, int *b) {
  if (*a > *b)
    swap(a, b);
}

int main() {
  int n1 = 10, n2 = 1;
  sort2(&n1, &n2);
  if (n1 == 1 && n2 == 10) std::cout << "correct" << std::endl;
  else std::cout << "wrong" << std::endl;
}
```

2問目
ポインタを3つ受け取ってそれらが指し示す値で並べ替える関数
```解答
void sort3(int *a, int *b, int *c) {
  sort2(a,b);
  sort2(b,c);
  sort2(a,b);
}
```
http://oshiete.goo.ne.jp/qa/4782859.html

# <a name="1121"></a>2015/11/21 [↑](#top)
* 参加者:

# <a name="1128"></a>2015/11/28 [↑](#top)
* 参加者:
